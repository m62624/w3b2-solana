import base64
import grpc
import os
import struct
import time

from solders.keypair import Keypair
from solders.message import Message
from solders.pubkey import Pubkey
from solders.transaction import Transaction
from solders.system_program import ID as SYS_PROGRAM_ID

# The following imports are generated by grpc_tools.protoc
import gateway_pb2
import gateway_pb2_grpc
import types_pb2

# --- Configuration ---
GATEWAY_HOST = os.getenv("GATEWAY_HOST", "localhost")
GATEWAY_PORT = os.getenv("GATEWAY_PORT", "50051")
GATEWAY_ADDRESS = f"{GATEWAY_HOST}:{GATEWAY_PORT}"

# --- Helper Functions ---
def get_program_id() -> Pubkey:
    """Reads the program ID from the environment variable."""
    program_id_str = os.getenv("W3B2_CONNECTOR__PROGRAM_ID")
    if not program_id_str:
        raise ValueError("W3B2_CONNECTOR__PROGRAM_ID environment variable not set")
    return Pubkey.from_string(program_id_str)

def pda_from_seeds(seeds, program_id: Pubkey) -> Pubkey:
    """Derives a Program-Derived Address (PDA) from seeds."""
    (pda, _bump) = Pubkey.find_program_address(seeds, program_id)
    return pda

def print_step(title):
    """Prints a formatted step title."""
    print("\n" + "="*60)
    print(f" {title}")
    print("="*60)

def wait_for_gateway(stub):
    """Waits for the gRPC gateway to become available."""
    print_step("Attempting to connect to gRPC gateway...")
    while True:
        try:
            # Use a simple, non-modifying RPC to check for health
            stub.PrepareAdminRegisterProfile(
                types_pb2.PrepareAdminRegisterProfileRequest(
                    authority_pubkey=str(Keypair().pubkey()),
                    communication_pubkey=str(Keypair().pubkey())
                ),
                timeout=5
            )
        # This will fail because the gateway will try to build a transaction
        # and fail because the authority doesn't exist, but it proves connectivity.
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.FAILED_PRECONDITION:
                print(f"Successfully connected to gateway at {GATEWAY_ADDRESS}")
                return
        except Exception as e:
            print(f"Gateway not ready yet, retrying in 5 seconds... (Error: {e})")
            time.sleep(5)


def sign_and_submit_tx(stub, unsigned_tx_bytes: bytes, signer: Keypair) -> str:
    """Signs and submits a transaction, returning the signature."""
    unsigned_tx = Transaction.from_bytes(unsigned_tx_bytes)
    message_to_sign = Message.from_bytes(unsigned_tx.message.to_bytes())

    # Sign the transaction with the appropriate keypair
    signed_tx = Transaction.new_signed_with_payer(
        [message_to_sign],
        [signer],
        unsigned_tx.message.recent_blockhash,
    )

    # Submit the signed transaction
    submit_req = types_pb2.SubmitTransactionRequest(
        signed_tx=signed_tx.to_bytes()
    )
    submit_res = stub.SubmitTransaction(submit_req)
    return submit_res.signature


# --- Main Client Logic ---
def run_client():
    """The main function to run the example client workflow."""
    channel = grpc.insecure_channel(GATEWAY_ADDRESS)
    stub = gateway_pb2_grpc.BridgeGatewayServiceStub(channel)

    wait_for_gateway(stub)

    # 1. Generate local keypairs
    print_step("1. Generating Local Keypairs")
    program_id = get_program_id()
    admin_authority = Keypair()
    user_authority = Keypair()
    # In this example, the admin also acts as the oracle
    oracle_authority = admin_authority

    print(f"Program ID:           {program_id}")
    print(f"Admin Authority:      {admin_authority.pubkey()}")
    print(f"User Authority:       {user_authority.pubkey()}")
    print(f"Oracle Authority:     {oracle_authority.pubkey()}")


    # 2. Register Admin Profile
    print_step("2. Registering Admin Profile")
    admin_pda = pda_from_seeds([b"admin", bytes(admin_authority.pubkey())], program_id)
    print(f"Derived Admin PDA:    {admin_pda}")

    prep_req = types_pb2.PrepareAdminRegisterProfileRequest(
        authority_pubkey=str(admin_authority.pubkey()),
        communication_pubkey=str(admin_authority.pubkey()), # Using same key for simplicity
    )
    prep_res = stub.PrepareAdminRegisterProfile(prep_req)
    signature = sign_and_submit_tx(stub, prep_res.unsigned_tx, admin_authority)
    print(f"Admin registration successful. Signature: {signature}")


    # 3. Register User Profile
    print_step("3. Registering User Profile")
    user_pda = pda_from_seeds([b"user", bytes(user_authority.pubkey()), bytes(admin_pda)], program_id)
    print(f"Derived User PDA:     {user_pda}")

    prep_req = types_pb2.PrepareUserCreateProfileRequest(
        authority_pubkey=str(user_authority.pubkey()),
        target_admin_pda=str(admin_pda),
        communication_pubkey=str(user_authority.pubkey()), # Using same key for simplicity
    )
    prep_res = stub.PrepareUserCreateProfile(prep_req)
    signature = sign_and_submit_tx(stub, prep_res.unsigned_tx, user_authority)
    print(f"User registration successful. Signature: {signature}")


    # 4. User Deposits Funds
    print_step("4. User Depositing Funds (0.1 SOL)")
    deposit_amount_lamports = 100_000_000 # 0.1 SOL

    prep_req = types_pb2.PrepareUserDepositRequest(
        authority_pubkey=str(user_authority.pubkey()),
        admin_profile_pda=str(admin_pda),
        amount=deposit_amount_lamports,
    )
    prep_res = stub.PrepareUserDeposit(prep_req)
    signature = sign_and_submit_tx(stub, prep_res.unsigned_tx, user_authority)
    print(f"User deposit successful. Signature: {signature}")


    # 5. Dispatch a Paid Command
    print_step("5. Dispatching a Paid Command")
    command_id = 101
    price = 50_000_000 # 0.05 SOL
    timestamp = int(time.time())
    payload = b"example_payload_data"

    # a. Oracle signs the message
    # The message format must match what the on-chain program expects:
    # [timestamp (8 bytes, little-endian), price (8 bytes, little-endian), payload (variable)]
    message_to_sign = (
        struct.pack("<q", timestamp) +
        struct.pack("<Q", price) +
        payload
    )
    oracle_signature = oracle_authority.sign(message_to_sign).to_bytes()

    print(f"Oracle signed message with signature: {base64.b64encode(oracle_signature).decode()}")

    # b. User prepares and submits the command transaction
    prep_req = types_pb2.PrepareUserDispatchCommandRequest(
        authority_pubkey=str(user_authority.pubkey()),
        target_admin_pda=str(admin_pda),
        command_id=command_id,
        price=price,
        timestamp=timestamp,
        payload=payload,
        oracle_pubkey=str(oracle_authority.pubkey()),
        oracle_signature=oracle_signature,
    )
    prep_res = stub.PrepareUserDispatchCommand(prep_req)

    # c. The user's wallet signs the final transaction
    signature = sign_and_submit_tx(stub, prep_res.unsigned_tx, user_authority)
    print(f"Paid command dispatched successfully. Signature: {signature}")
    print("\n" + "="*60)
    print(" Client workflow completed successfully!")
    print("="*60)


if __name__ == "__main__":
    run_client()