//! This module contains integration tests for expected failure scenarios.
//! These tests ensure that the program's constraints and error handling
//! work as intended, preventing unauthorized or invalid actions.

mod instructions;

use instructions::*;
use solana_program::native_token::LAMPORTS_PER_SOL;
use solana_sdk::signer::Signer;
use w3b2_solana_program::{errors::BridgeError, state::PriceEntry};

/// Converts a program-specific error enum into its on-chain numeric code.
/// Anchor assigns codes starting from 6000.
fn to_error_code(error: BridgeError) -> u32 {
    // This mirrors Anchor's internal behavior where custom errors start at 6000.
    // The `as u32` cast on the enum variant gives its position (0, 1, 2, ...).
    6000 + (error as u32)
}

/// Tests that an instruction fails with `SignerUnauthorized` when an incorrect
/// authority attempts to modify a profile.
#[test]
fn test_fail_unauthorized_signer() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // The legitimate owner of the profile.
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());

    // A legitimate user.
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let user_pda = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );

    // A malicious actor who will try to call the instruction.
    let malicious_actor = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);

    // === 2. Act ===
    println!("Malicious actor attempting to log an action on behalf of others...");

    // The malicious actor calls `log_action`, passing in the legitimate user's and admin's
    // profiles, but signing the transaction with their own key.
    // The program should reject this because the signer is not the authority of either profile.
    let log_ix = log::ix_log_action(&malicious_actor, user_pda, admin_pda, 999, 999);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[log_ix],
        Some(&malicious_actor.pubkey()),
    );
    tx.sign(&[&malicious_actor], svm.latest_blockhash());

    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");

    // Use the constant generated by the `#[error_code]` macro.
    // This constant holds the correct on-chain error number (e.g., 6000).
    assert_eq!(error_code, to_error_code(BridgeError::SignerUnauthorized));

    println!("✅ Unauthorized Signer Test Passed!");
    println!(
        "   -> Correctly failed with error: SignerUnauthorized ({})",
        error_code
    );
}

/// Tests that an admin cannot withdraw more funds than are in their internal `balance`.
#[test]
fn test_fail_insufficient_admin_balance() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // Create Admin and set a price
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());
    let command_price = 1 * LAMPORTS_PER_SOL;
    admin::update_prices(
        &mut svm,
        &admin_authority,
        vec![PriceEntry::new(1, command_price)],
    );

    // Create User, deposit funds, and pay the admin
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let _ = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );
    user::deposit(&mut svm, &user_authority, admin_pda, command_price);
    user::dispatch_command(&mut svm, &user_authority, admin_pda, 1, vec![]);

    // At this point, the admin's internal balance is `command_price`.
    // The admin will try to withdraw *more* than that.
    let withdraw_amount = command_price + 1;

    // === 2. Act ===
    println!(
        "Admin with balance {} attempting to withdraw {}...",
        command_price, withdraw_amount
    );

    // For failure tests, we build and send the transaction manually to capture the `Result`.
    let withdraw_ix =
        admin::ix_withdraw(&admin_authority, create_keypair().pubkey(), withdraw_amount);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[withdraw_ix],
        Some(&admin_authority.pubkey()),
    );
    tx.sign(&[&admin_authority], svm.latest_blockhash());

    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");

    assert_eq!(
        error_code,
        to_error_code(BridgeError::InsufficientAdminBalance)
    );

    println!("✅ Insufficient Admin Balance Test Passed!");
    println!(
        "   -> Correctly failed with error: InsufficientAdminBalance ({})",
        error_code
    );
}

/// Tests that a command fails if its payload is larger than `MAX_PAYLOAD_SIZE`.
#[test]
fn test_fail_payload_too_large() {
    // === 1. Arrange ===
    let mut svm = setup_svm();
    let (admin_authority, _, _, user_pda) = setup_profiles(&mut svm);

    // Create a payload that is one byte too large.
    let large_payload = vec![0u8; w3b2_solana_program::instructions::MAX_PAYLOAD_SIZE + 1];

    // === 2. Act ===
    println!("Admin dispatching command with oversized payload...");
    let dispatch_ix = admin::ix_dispatch_command(&admin_authority, user_pda, 1, large_payload);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[dispatch_ix],
        Some(&admin_authority.pubkey()),
    );
    tx.sign(&[&admin_authority], svm.latest_blockhash());
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");
    assert_eq!(error_code, to_error_code(BridgeError::PayloadTooLarge));

    println!("✅ Payload Too Large Test Passed!");
    println!(
        "   -> Correctly failed with error: PayloadTooLarge ({})",
        error_code
    );
}

/// Tests that a user cannot execute a paid command if their `deposit_balance` is insufficient.
#[test]
fn test_fail_insufficient_deposit_balance() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // Create an admin and set a price for a command.
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());
    let command_price = 1 * LAMPORTS_PER_SOL;
    admin::update_prices(
        &mut svm,
        &admin_authority,
        vec![PriceEntry::new(1, command_price)],
    );

    // Create a user linked to the admin, but DO NOT deposit any funds.
    // The user profile will have `deposit_balance = 0`.
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let _ = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );

    // === 2. Act ===
    println!("User with 0 balance attempting to execute a paid command...");
    let dispatch_ix = user::ix_dispatch_command(&user_authority, admin_pda, 1, vec![]);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[dispatch_ix],
        Some(&user_authority.pubkey()),
    );
    tx.sign(&[&user_authority], svm.latest_blockhash());
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");

    assert_eq!(
        error_code,
        to_error_code(BridgeError::InsufficientDepositBalance)
    );

    println!("✅ Insufficient Deposit Balance Test Passed!");
    println!(
        "   -> Correctly failed with error: InsufficientDepositBalance ({})",
        error_code
    );
}
