//! This module contains integration tests for expected failure scenarios.
//! These tests ensure that the program's constraints and error handling
//! work as intended, preventing unauthorized or invalid actions.

mod instructions;

use anchor_lang::prelude::Clock;
use instructions::*;
use solana_program::native_token::LAMPORTS_PER_SOL;
use solana_sdk::signer::Signer;
use w3b2_solana_program::errors::BridgeError;

/// Converts a program-specific error enum into its on-chain numeric code.
/// Anchor assigns codes starting from 6000.
fn to_error_code(error: BridgeError) -> u32 {
    // This mirrors Anchor's internal behavior where custom errors start at 6000.
    // The `as u32` cast on the enum variant gives its position (0, 1, 2, ...).
    6000 + (error as u32)
}

/// Tests that an instruction fails with `SignerUnauthorized` when an incorrect
/// authority attempts to modify a profile.
#[test]
fn test_fail_unauthorized_signer() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // The legitimate owner of the profile.
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());

    // A legitimate user.
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let user_pda = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );

    // A malicious actor who will try to call the instruction.
    let malicious_actor = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);

    // === 2. Act ===
    println!("Malicious actor attempting to log an action on behalf of others...");

    // The malicious actor calls `log_action`, passing in the legitimate user's and admin's
    // profiles, but signing the transaction with their own key.
    // The program should reject this because the signer is not the authority of either profile.
    let log_ix = log::ix_log_action(&malicious_actor, user_pda, admin_pda, 999, 999);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[log_ix],
        Some(&malicious_actor.pubkey()),
    );
    tx.sign(&[&malicious_actor], svm.latest_blockhash());

    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");

    // Use the constant generated by the `#[error_code]` macro.
    // This constant holds the correct on-chain error number (e.g., 6000).
    assert_eq!(error_code, to_error_code(BridgeError::SignerUnauthorized));

    println!("✅ Unauthorized Signer Test Passed!");
    println!("   -> Correctly failed with error: SignerUnauthorized ({error_code})");
}

/// Tests that an admin cannot withdraw more funds than are in their internal `balance`.
#[test]
fn test_fail_insufficient_admin_balance() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // Create Admin and set a price
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());
    let command_price = LAMPORTS_PER_SOL;

    // Create User, deposit funds, and pay the admin
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let _ = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );
    user::deposit(&mut svm, &user_authority, admin_pda, command_price);

    let timestamp = svm.get_sysvar::<Clock>().unix_timestamp;

    user::dispatch_command(
        &mut svm,
        &user_authority,
        admin_pda,
        &admin_authority,
        1,
        command_price,
        timestamp,
        vec![],
    );

    // At this point, the admin's internal balance is `command_price`.
    // The admin will try to withdraw *more* than that.
    let withdraw_amount = command_price + 1;

    // === 2. Act ===
    println!("Admin with balance {command_price} attempting to withdraw {withdraw_amount}...");

    // For failure tests, we build and send the transaction manually to capture the `Result`.
    let withdraw_ix =
        admin::ix_withdraw(&admin_authority, create_keypair().pubkey(), withdraw_amount);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[withdraw_ix],
        Some(&admin_authority.pubkey()),
    );
    tx.sign(&[&admin_authority], svm.latest_blockhash());

    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");

    assert_eq!(
        error_code,
        to_error_code(BridgeError::InsufficientAdminBalance)
    );

    println!("✅ Insufficient Admin Balance Test Passed!");
    println!("   -> Correctly failed with error: InsufficientAdminBalance ({error_code})");
}

/// Tests that a command fails if its payload is larger than `MAX_PAYLOAD_SIZE`.
#[test]
fn test_fail_payload_too_large() {
    // === 1. Arrange ===
    let mut svm = setup_svm();
    let (admin_authority, _, _, user_pda) = setup_profiles(&mut svm);

    // Create a payload that is one byte too large.
    let large_payload = vec![0u8; w3b2_solana_program::instructions::MAX_PAYLOAD_SIZE + 1];

    // === 2. Act ===
    println!("Admin dispatching command with oversized payload...");
    let dispatch_ix = admin::ix_dispatch_command(&admin_authority, user_pda, 1, large_payload);
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[dispatch_ix],
        Some(&admin_authority.pubkey()),
    );
    tx.sign(&[&admin_authority], svm.latest_blockhash());
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");
    assert_eq!(error_code, to_error_code(BridgeError::PayloadTooLarge));

    println!("✅ Payload Too Large Test Passed!");
    println!("   -> Correctly failed with error: PayloadTooLarge ({error_code})");
}

/// Tests that a user cannot execute a paid command if their `deposit_balance` is insufficient.
#[test]
fn test_fail_insufficient_deposit_balance() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // Create an admin and set a price for a command.
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());
    let command_price = LAMPORTS_PER_SOL;

    // Create a user linked to the admin, but DO NOT deposit any funds.
    // The user profile will have `deposit_balance = 0`.
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let _ = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );

    let timestamp = svm.get_sysvar::<Clock>().unix_timestamp;

    // === 2. Act ===
    println!("User with 0 balance attempting to execute a paid command...");

    // Even for a failure test, we need to supply the precedent Ed25519 instruction
    // that the on-chain program expects to see. The program should fail on the
    // balance check before it even gets to verifying the signature details.
    let message = [
        1u16.to_le_bytes().as_ref(),
        command_price.to_le_bytes().as_ref(),
        timestamp.to_le_bytes().as_ref(),
    ]
    .concat();

    let signature = admin_authority.sign_message(&message);
    let pubkey_bytes = admin_authority.pubkey().to_bytes();
    let signature_bytes: [u8; 64] = signature.as_ref().try_into().unwrap();
    let ed25519_ix = solana_sdk::ed25519_instruction::new_ed25519_instruction_with_signature(
        &message,
        &signature_bytes,
        &pubkey_bytes,
    );

    let dispatch_ix = user::ix_dispatch_command(
        &user_authority,
        admin_pda,
        1,
        command_price,
        timestamp,
        vec![],
    );
    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[ed25519_ix, dispatch_ix],
        Some(&user_authority.pubkey()),
    );
    tx.sign(&[&user_authority], svm.latest_blockhash());
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(
        result.is_err(),
        "Transaction should have failed but it succeeded."
    );
    println!("Transaction correctly failed as expected.");

    let error_code = get_error_code(result).expect("Failed to extract error code.");

    assert_eq!(
        error_code,
        to_error_code(BridgeError::InsufficientDepositBalance)
    );

    println!("✅ Insufficient Deposit Balance Test Passed!");
    println!("   -> Correctly failed with error: InsufficientDepositBalance ({error_code})");
}

/// Tests that `user_dispatch_command` fails with `InvalidOracleSigner` if the
/// signature is from an oracle not authorized by the `AdminProfile`.
#[test]
fn test_fail_invalid_oracle_signer() {
    // === 1. Arrange ===
    let mut svm = setup_svm();

    // Create an admin and set a *legitimate* oracle.
    let admin_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let admin_pda = admin::create_profile(&mut svm, &admin_authority, create_keypair().pubkey());
    let legitimate_oracle = create_keypair();
    admin::set_config(
        &mut svm,
        &admin_authority,
        Some(legitimate_oracle.pubkey()),
        None,
        None,
    );

    // Create a user.
    let user_authority = create_funded_keypair(&mut svm, 10 * LAMPORTS_PER_SOL);
    let _ = user::create_profile(
        &mut svm,
        &user_authority,
        create_keypair().pubkey(),
        admin_pda,
    );

    // A malicious oracle tries to sign the message.
    let rogue_oracle = create_keypair();

    let command_id = 1u16;
    let price = 1000u64;
    let timestamp = svm.get_sysvar::<Clock>().unix_timestamp;

    let message = [
        command_id.to_le_bytes().as_ref(),
        price.to_le_bytes().as_ref(),
        timestamp.to_le_bytes().as_ref(),
    ]
    .concat();

    // The signature is created by the ROGUE oracle.
    let signature = rogue_oracle.sign_message(&message);

    // The Ed25519 instruction correctly identifies the signer as the rogue oracle.
    let pubkey_bytes = rogue_oracle.pubkey().to_bytes();
    let signature_bytes: [u8; 64] = signature.as_ref().try_into().unwrap();
    let ed25519_ix = solana_sdk::ed25519_instruction::new_ed25519_instruction_with_signature(
        &message,
        &signature_bytes,
        &pubkey_bytes,
    );

    let dispatch_ix = user::ix_dispatch_command(
        &user_authority,
        admin_pda,
        command_id,
        price,
        timestamp,
        vec![],
    );

    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[ed25519_ix, dispatch_ix],
        Some(&user_authority.pubkey()),
    );
    tx.sign(&[&user_authority], svm.latest_blockhash());

    // === 2. Act ===
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(result.is_err(), "Transaction should have failed");
    let error_code = get_error_code(result).unwrap();
    assert_eq!(error_code, to_error_code(BridgeError::InvalidOracleSigner));

    println!("✅ Invalid Oracle Signer Test Passed!");
}

/// Tests that `user_dispatch_command` fails with `TimestampTooOld` if the
/// oracle's signature has expired.
#[test]
fn test_fail_timestamp_too_old() {
    // === 1. Arrange ===
    let mut svm = setup_svm();
    let (admin_authority, admin_pda, user_authority, _) = setup_profiles(&mut svm);

    let command_id = 1u16;
    let price = 1000u64;

    // The oracle (the admin in this case) signs a message with a timestamp in the past.
    let old_timestamp = svm.get_sysvar::<Clock>().unix_timestamp - 100; // 100 seconds ago

    let message = [
        command_id.to_le_bytes().as_ref(),
        price.to_le_bytes().as_ref(),
        old_timestamp.to_le_bytes().as_ref(),
    ]
    .concat();

    let signature = admin_authority.sign_message(&message);
    let pubkey_bytes = admin_authority.pubkey().to_bytes();
    let signature_bytes: [u8; 64] = signature.as_ref().try_into().unwrap();
    let ed25519_ix = solana_sdk::ed25519_instruction::new_ed25519_instruction_with_signature(
        &message,
        &signature_bytes,
        &pubkey_bytes,
    );

    // Advance the SVM clock to make the timestamp definitively "too old".
    let mut clock = svm.get_sysvar::<Clock>();
    clock.unix_timestamp += w3b2_solana_program::instructions::MAX_TIMESTAMP_AGE_SECONDS + 10;
    svm.set_sysvar(&clock);

    let dispatch_ix = user::ix_dispatch_command(
        &user_authority,
        admin_pda,
        command_id,
        price,
        old_timestamp, // Pass the old timestamp
        vec![],
    );

    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[ed25519_ix, dispatch_ix],
        Some(&user_authority.pubkey()),
    );
    tx.sign(&[&user_authority], svm.latest_blockhash());

    // === 2. Act ===
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(result.is_err(), "Transaction should have failed");
    let error_code = get_error_code(result).unwrap();
    assert_eq!(error_code, to_error_code(BridgeError::TimestampTooOld));

    println!("✅ Timestamp Too Old Test Passed!");
}

/// Tests that `user_dispatch_command` fails with `SignatureVerificationFailed`
/// if the arguments passed to the instruction do not match the data signed by the oracle.
#[test]
fn test_fail_signature_verification_failed() {
    // === 1. Arrange ===
    let mut svm = setup_svm();
    let (admin_authority, admin_pda, user_authority, _) = setup_profiles(&mut svm);

    let command_id = 1u16;
    let signed_price = 1000u64; // The price the oracle actually signed
    let attempted_price = 1u64; // The price the user tries to pass to the instruction
    let timestamp = svm.get_sysvar::<Clock>().unix_timestamp;

    // The oracle signs the message with the CORRECT price.
    let message = [
        command_id.to_le_bytes().as_ref(),
        signed_price.to_le_bytes().as_ref(),
        timestamp.to_le_bytes().as_ref(),
    ]
    .concat();

    let signature = admin_authority.sign_message(&message);
    let pubkey_bytes = admin_authority.pubkey().to_bytes();
    let signature_bytes: [u8; 64] = signature.as_ref().try_into().unwrap();
    let ed25519_ix = solana_sdk::ed25519_instruction::new_ed25519_instruction_with_signature(
        &message,
        &signature_bytes,
        &pubkey_bytes,
    );

    // The user calls the instruction with the WRONG price.
    let dispatch_ix = user::ix_dispatch_command(
        &user_authority,
        admin_pda,
        command_id,
        attempted_price, // Maliciously low price
        timestamp,
        vec![],
    );

    let mut tx = solana_sdk::transaction::Transaction::new_with_payer(
        &[ed25519_ix, dispatch_ix],
        Some(&user_authority.pubkey()),
    );
    tx.sign(&[&user_authority], svm.latest_blockhash());

    // === 2. Act ===
    let result = svm.send_transaction(tx);

    // === 3. Assert ===
    assert!(result.is_err(), "Transaction should have failed");
    let error_code = get_error_code(result).unwrap();
    assert_eq!(
        error_code,
        to_error_code(BridgeError::SignatureVerificationFailed)
    );

    println!("✅ Signature Verification Failed (Price Mismatch) Test Passed!");
}
